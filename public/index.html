<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector MCP - Index Manager</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        #status-message {
            position: absolute;
            margin: auto;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .section h2 {
            margin-bottom: 15px;
            color: #2c3e50;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        input, textarea, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        textarea {
            resize: vertical;
            min-height: 100px;
        }
        
        button {
            background: #3498db;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        button.danger {
            background: #e74c3c;
        }
        
        button.danger:hover {
            background: #c0392b;
        }
        
        .project-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
        }
        
        .project-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background: #f9f9f9;
        }
        
        .project-card h3 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .project-stats {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
        }
        
        .log-container {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        .status {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
        
        .flex {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .flex-wrap {
            flex-wrap: wrap;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 10% auto;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .close {
            color: #aaa;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: #000;
        }

        .form-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .form-row button {
            margin: 0;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background-color: #ecf0f1;
            border-radius: 3px;
            margin: 8px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background-color: #3498db;
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .progress-fill.completed {
            background-color: #27ae60;
        }

        .progress-fill.failed {
            background-color: #e74c3c;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Vector MCP - Index Manager</h1>
            <p>Manage your codebase indexes for enhanced Claude context</p>
        </div>

        <div id="status-message"></div>

        <div class="section">
            <h2>Create New Index</h2>
            <div class="form-group">
                <label for="project-id">Project ID:</label>
                <input type="text" id="project-id" placeholder="e.g., my-webapp-v2" required>
            </div>
            <div class="form-group">
                <label for="directory-path">Directory Path:</label>
                <div class="form-row">
                    <input type="text" id="directory-path" placeholder="e.g., /Users/username/projects/my-app" required style="flex: 1;">
                </div>
                <small id="path-help" style="color: #666; font-size: 12px;">Tip: Use absolute paths for best results</small>
                <div id="path-validation" style="margin-top: 5px;"></div>
            </div>
            <div class="form-group">
                <label for="exclude-patterns">Additional Exclude Patterns (one per line):</label>
                <textarea id="exclude-patterns" placeholder="*.log&#10;temp/**&#10;*.tmp"></textarea>
            </div>
            <button onclick="createIndex()" id="create-btn">Create Index</button>
            <button onclick="testCurrentDir()" id="test-btn">Test with Current Directory</button>
        </div>

        <div class="section">
            <h2>Existing Projects</h2>
            <button onclick="loadProjects()" id="refresh-btn">Refresh</button>
            <div id="project-list" class="project-list">
                <!-- Projects will be loaded here -->
            </div>
        </div>

        <div class="section">
            <h2>Search Test</h2>
            <div class="form-group">
                <label for="search-query">Search Query:</label>
                <input type="text" id="search-query" placeholder="e.g., function to handle authentication">
            </div>
            <div class="form-group">
                <label for="search-project">Project (optional):</label>
                <select id="search-project">
                    <option value="">All projects</option>
                </select>
            </div>
            <div class="flex">
                <button onclick="testSearch()" id="search-btn">Search</button>
                <input type="number" id="search-limit" value="5" min="1" max="20" style="width: 80px;" placeholder="Limit">
            </div>
            <div id="search-results"></div>
        </div>

        <div class="section">
            <h2>Active Jobs</h2>
            <button onclick="loadJobs()" id="refresh-jobs-btn">Refresh</button>
            <div id="jobs-list">
                <!-- Active jobs will be loaded here -->
            </div>
        </div>

        <div class="section">
            <h2>Server Logs</h2>
            <div class="form-row">
                <button onclick="clearLogs()">Clear Server Logs</button>
                <span id="log-status" style="color: #666; font-size: 14px;">Connecting to log stream...</span>
            </div>
            <div id="logs" class="log-container"></div>
        </div>
    </div>

    <!-- Update Project Modal -->
    <div id="updateModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Update Project</h3>
                <span class="close" onclick="closeModal('updateModal')">&times;</span>
            </div>
            <div class="form-group">
                <label for="modal-project-id">Project ID:</label>
                <input type="text" id="modal-project-id" readonly>
            </div>
            <div class="form-group">
                <label for="modal-directory-path">Directory Path:</label>
                <input type="text" id="modal-directory-path" placeholder="/path/to/project" required>
            </div>
            <div class="form-group">
                <label for="modal-exclude-patterns">Additional Exclude Patterns (one per line):</label>
                <textarea id="modal-exclude-patterns" placeholder="*.log&#10;temp/**&#10;*.tmp"></textarea>
            </div>
            <div class="form-row">
                <button onclick="confirmUpdate()" id="modal-update-btn">Update Project</button>
                <button onclick="closeModal('updateModal')" style="background: #95a5a6;">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        let logs = [];
        let statusTimeout = null;

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            logs.push(`[${timestamp}] ${message}`);
            updateLogDisplay();
        }

        function updateLogDisplay() {
            const logContainer = document.getElementById('logs');
            logContainer.textContent = logs.join('\n');
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        async function clearLogs() {
            // Clear the server.log file
            try {
                updateLogStatus('üßπ Clearing logs...', '#f39c12');
                const response = await fetch('/api/logs/clear', { method: 'POST' });
                const result = await response.json();
                
                if (response.ok) {
                    // Clear the local display immediately
                    logs = [];
                    updateLogDisplay();
                    showStatus('Server logs cleared - stream continues monitoring', 'success');
                    updateLogStatus('üî¥ Live streaming (cleared)', '#27ae60');
                } else {
                    showStatus(`Error clearing server logs: ${result.error}`, 'error');
                    updateLogStatus('‚ùå Error clearing logs', '#e74c3c');
                }
            } catch (error) {
                showStatus('Network error clearing logs', 'error');
                updateLogStatus('‚ùå Network error', '#e74c3c');
            }
        }

        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status-message');
            clearTimeout(statusTimeout);
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
            statusTimeout = setTimeout(() => {
                statusDiv.className = '';
                statusDiv.textContent = '';
            }, 10000);
        }

        async function createIndex() {
            const projectId = document.getElementById('project-id').value.trim();
            const directoryPath = document.getElementById('directory-path').value.trim();
            const excludePatterns = document.getElementById('exclude-patterns').value
                .split('\n')
                .map(p => p.trim())
                .filter(p => p);

            if (!projectId || !directoryPath) {
                showStatus('Please provide both Project ID and Directory Path', 'error');
                return;
            }

            const btn = document.getElementById('create-btn');
            btn.disabled = true;
            btn.textContent = 'Starting...';

            try {
                log(`Starting index creation for project: ${projectId}`);
                log(`Directory: ${directoryPath}`);
                
                const response = await fetch('/api/projects', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        projectId,
                        directoryPath,
                        excludePatterns
                    })
                });

                const result = await response.json();
                
                if (response.ok && result.jobId) {
                    showStatus('Indexing job started! Check logs for progress...', 'info');
                    btn.textContent = 'Indexing...';
                    
                    // Start monitoring the job
                    monitorJob(result.jobId, () => {
                        btn.disabled = false;
                        btn.textContent = 'Create Index';
                        loadProjects();
                    });
                } else {
                    log(`‚ùå Error: ${result.error || 'Unknown error'}`);
                    showStatus(result.error || 'Unknown error', 'error');
                    btn.disabled = false;
                    btn.textContent = 'Create Index';
                }
            } catch (error) {
                log(`‚ùå Network error: ${error.message}`);
                showStatus('Network error occurred', 'error');
                btn.disabled = false;
                btn.textContent = 'Create Index';
            }
        }

        async function testCurrentDir() {
            const btn = document.getElementById('test-btn');
            btn.disabled = true;
            btn.textContent = 'Starting...';

            try {
                const response = await fetch('/api/test-current-dir', {
                    method: 'POST'
                });

                const result = await response.json();
                
                if (response.ok && result.jobId) {
                    showStatus('Test indexing job started! Check logs for progress...', 'info');
                    btn.textContent = 'Testing...';
                    
                    // Start monitoring the job
                    monitorJob(result.jobId, () => {
                        btn.disabled = false;
                        btn.textContent = 'Test with Current Directory';
                        loadProjects();
                    });
                } else {
                    log(`‚ùå Test error: ${result.error || 'Unknown error'}`);
                    showStatus(result.error || 'Unknown error', 'error');
                    btn.disabled = false;
                    btn.textContent = 'Test with Current Directory';
                }
            } catch (error) {
                log(`‚ùå Network error: ${error.message}`);
                showStatus('Network error occurred', 'error');
                btn.disabled = false;
                btn.textContent = 'Test with Current Directory';
            }
        }

        async function loadProjects() {
            try {
                const response = await fetch('/api/projects');
                const projects = await response.json();
                
                const projectList = document.getElementById('project-list');
                const searchSelect = document.getElementById('search-project');
                
                // Update search dropdown
                searchSelect.innerHTML = '<option value="">All projects</option>';
                
                if (projects.length === 0) {
                    projectList.innerHTML = '<p>No projects found. Create your first index!</p>';
                    return;
                }
                
                projectList.innerHTML = projects.map(project => `
                    <div class="project-card">
                        <h3>${project.projectId}</h3>
                        <div class="project-stats">
                            <div>Documents: ${project.documentCount}</div>
                            <div>Last Modified: ${new Date(project.lastModified).toLocaleString()}</div>
                            ${project.directoryPath ? `<div>Path: ${project.directoryPath}</div>` : ''}
                            ${project.excludePatterns && project.excludePatterns.length > 0 ? 
                              `<div>Excludes: ${project.excludePatterns.length} patterns</div>` : ''}
                        </div>
                        <button onclick="updateProject('${project.projectId}')" style="background: #f39c12;">Update</button>
                        <button onclick="deleteProject('${project.projectId}')" class="danger">Delete</button>
                        <button onclick="showProjectDetails('${project.projectId}')">Details</button>
                    </div>
                `).join('');
                
                // Populate search dropdown
                projects.forEach(project => {
                    const option = document.createElement('option');
                    option.value = project.projectId;
                    option.textContent = project.projectId;
                    searchSelect.appendChild(option);
                });
                
            } catch (error) {
                log(`‚ùå Error loading projects: ${error.message}`);
                showStatus('Error loading projects', 'error');
            }
        }

        async function updateProject(projectId) {
            try {
                // Get project metadata to pre-fill the form
                const metadataResponse = await fetch(`/api/projects/${projectId}/metadata`);
                let defaultPath = '';
                let defaultPatterns = '';
                
                if (metadataResponse.ok) {
                    const metadata = await metadataResponse.json();
                    defaultPath = metadata.directoryPath || '';
                    defaultPatterns = metadata.excludePatterns ? metadata.excludePatterns.join('\n') : '';
                }
                
                // Fill modal form
                document.getElementById('modal-project-id').value = projectId;
                document.getElementById('modal-directory-path').value = defaultPath;
                document.getElementById('modal-exclude-patterns').value = defaultPatterns;
                
                // Show modal
                document.getElementById('updateModal').style.display = 'block';
                
            } catch (error) {
                log(`‚ùå Error loading project metadata: ${error.message}`);
                showStatus('Error loading project data', 'error');
            }
        }

        async function confirmUpdate() {
            const projectId = document.getElementById('modal-project-id').value;
            const directoryPath = document.getElementById('modal-directory-path').value.trim();
            const excludePatterns = document.getElementById('modal-exclude-patterns').value;
            const excludeList = excludePatterns ? excludePatterns.split('\n').map(p => p.trim()).filter(p => p) : [];

            if (!directoryPath) {
                showStatus('Please enter a directory path', 'error');
                return;
            }

            try {
                closeModal('updateModal');
                
                const response = await fetch(`/api/projects/${projectId}/update`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        directoryPath,
                        excludePatterns: excludeList
                    })
                });

                const result = await response.json();
                
                if (response.ok && result.jobId) {
                    showStatus('Delta update job started! Check logs for progress...', 'info');
                    
                    // Start monitoring the job
                    monitorJob(result.jobId, () => {
                        loadProjects();
                    });
                } else {
                    log(`‚ùå Update error: ${result.error || 'Unknown error'}`);
                    showStatus(result.error || 'Unknown error', 'error');
                }
            } catch (error) {
                log(`‚ùå Network error: ${error.message}`);
                showStatus('Network error occurred', 'error');
            }
        }

        async function deleteProject(projectId) {
            if (!confirm(`Are you sure you want to delete project "${projectId}"? This cannot be undone.`)) {
                return;
            }

            try {
                log(`Deleting project: ${projectId}`);
                
                const response = await fetch(`/api/projects/${projectId}`, {
                    method: 'DELETE'
                });

                const result = await response.json();
                
                if (response.ok) {
                    log(`‚úÖ Project deleted: ${result.deletedCount} documents removed`);
                    showStatus('Project deleted successfully', 'success');
                    loadProjects();
                } else {
                    log(`‚ùå Delete error: ${result.error}`);
                    showStatus(result.error, 'error');
                }
            } catch (error) {
                log(`‚ùå Network error: ${error.message}`);
                showStatus('Network error occurred', 'error');
            }
        }

        async function showProjectDetails(projectId) {
            try {
                const response = await fetch(`/api/projects/${projectId}/stats`);
                const stats = await response.json();
                
                log(`Project: ${stats.projectId}`);
                log(`Total Documents: ${stats.totalDocuments}`);
                log(`Total Files: ${stats.totalFiles}`);
                log(`Files: ${stats.files.join(', ')}`);
                
            } catch (error) {
                log(`‚ùå Error loading project details: ${error.message}`);
            }
        }

        async function testSearch() {
            const query = document.getElementById('search-query').value.trim();
            const projectId = document.getElementById('search-project').value;
            const limit = parseInt(document.getElementById('search-limit').value) || 5;

            if (!query) {
                showStatus('Please enter a search query', 'error');
                return;
            }

            const btn = document.getElementById('search-btn');
            btn.disabled = true;
            btn.textContent = 'Searching...';

            try {
                log(`Searching for: "${query}"`);
                if (projectId) log(`Project filter: ${projectId}`);
                
                const response = await fetch('/mcp/context', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        query,
                        topK: limit,
                        projectId: projectId || undefined
                    })
                });

                const result = await response.json();
                
                if (response.ok) {
                    log(`‚úÖ Search completed! Found ${result.results.length} results`);
                    
                    const resultsDiv = document.getElementById('search-results');
                    resultsDiv.innerHTML = `
                        <h3>Search Results (${result.results.length})</h3>
                        ${result.results.map((item, index) => `
                            <div style="border: 1px solid #ddd; margin: 10px 0; padding: 10px; border-radius: 4px;">
                                <strong>#${index + 1} - ${item.filePath || 'Unknown file'}</strong> 
                                <span style="color: #666;">(Score: ${item.score.toFixed(4)})</span>
                                ${item.projectId ? `<br><small>Project: ${item.projectId}</small>` : ''}
                                <pre style="margin: 10px 0; background: #f5f5f5; padding: 10px; border-radius: 4px; white-space: pre-wrap; max-height: 200px; overflow-y: auto;">${item.content}</pre>
                            </div>
                        `).join('')}
                    `;
                    
                } else {
                    log(`‚ùå Search error: ${result.error}`);
                    showStatus(result.error, 'error');
                }
            } catch (error) {
                log(`‚ùå Network error: ${error.message}`);
                showStatus('Network error occurred', 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Search';
            }
        }

        // Job monitoring function
        const activeJobs = new Set();
        
        async function monitorJob(jobId, onComplete) {
            if (activeJobs.has(jobId)) {
                return; // Already monitoring this job
            }
            
            activeJobs.add(jobId);
            
            const pollInterval = 3000; // Poll every 3 seconds
            let attempts = 0;
            const maxAttempts = 600; // Max 30 minutes (600 * 3 seconds)
            
            const poll = async () => {
                attempts++;
                
                try {
                    const response = await fetch(`/api/jobs/${jobId}`);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const job = await response.json();
                    
                    // Update UI with job progress
                    updateJobStatus(job);
                    
                    if (job.status === 'completed') {
                        showStatus('Job completed successfully!', 'success');
                        activeJobs.delete(jobId);
                        if (onComplete) onComplete();
                        return;
                    }
                    
                    if (job.status === 'failed') {
                        showStatus(`Job failed: ${job.error || 'Unknown error'}`, 'error');
                        activeJobs.delete(jobId);
                        if (onComplete) onComplete();
                        return;
                    }
                    
                    // Continue polling if job is still running
                    if (job.status === 'running' || job.status === 'pending') {
                        if (attempts < maxAttempts) {
                            setTimeout(poll, pollInterval);
                        } else {
                            showStatus('Job monitoring timeout - check logs for status', 'error');
                            activeJobs.delete(jobId);
                            if (onComplete) onComplete();
                        }
                    }
                    
                } catch (error) {
                    if (attempts < maxAttempts) {
                        setTimeout(poll, pollInterval);
                    } else {
                        activeJobs.delete(jobId);
                        if (onComplete) onComplete();
                    }
                }
            };
            
            // Start polling
            setTimeout(poll, 1000); // First poll after 1 second
        }
        
        function updateJobStatus(job) {
            const progress = job.progress || 0;
            const status = job.status || 'unknown';
            
            // Since we're streaming from server.log, we don't need to duplicate job logs here
            // The server logs will automatically appear in the stream
            
            // Update status message for active jobs
            if (status === 'running') {
                if (progress > 0) {
                    showStatus(`Job ${job.id.substr(-8)}: ${progress.toFixed(1)}% complete`, 'info');
                } else {
                    showStatus(`Job ${job.id.substr(-8)}: Running...`, 'info');
                }
            } else if (status === 'pending') {
                showStatus(`Job ${job.id.substr(-8)}: Pending...`, 'info');
            }
        }

        async function loadJobs() {
            try {
                const response = await fetch('/api/jobs');
                const jobs = await response.json();
                
                const jobsList = document.getElementById('jobs-list');
                
                if (jobs.length === 0) {
                    jobsList.innerHTML = '<p>No jobs found.</p>';
                    return;
                }
                
                // Filter to show recent jobs (last 24 hours) and active jobs
                const recentJobs = jobs.filter(job => {
                    const age = Date.now() - new Date(job.startTime).getTime();
                    return age < 24 * 60 * 60 * 1000 || job.status === 'running' || job.status === 'pending';
                }).slice(0, 10); // Show max 10 recent jobs
                
                jobsList.innerHTML = recentJobs.map(job => {
                    const duration = job.endTime ? 
                        Math.round((new Date(job.endTime) - new Date(job.startTime)) / 1000) + 's' : 
                        Math.round((Date.now() - new Date(job.startTime)) / 1000) + 's';
                    
                    const statusColor = {
                        'pending': '#f39c12',
                        'running': '#3498db', 
                        'completed': '#27ae60',
                        'failed': '#e74c3c'
                    }[job.status] || '#95a5a6';
                    
                    const progressBar = (job.status === 'running' || job.status === 'completed' || job.status === 'failed') && job.progress > 0 ? `
                        <div class="progress-bar">
                            <div class="progress-fill ${job.status}" style="width: ${job.progress}%"></div>
                        </div>
                    ` : '';

                    return `
                        <div class="project-card" style="border-left: 4px solid ${statusColor};">
                            <h4>${job.type.toUpperCase()} - ${job.projectId}</h4>
                            <div class="project-stats">
                                <div><strong>Status:</strong> ${job.status.charAt(0).toUpperCase() + job.status.slice(1)}</div>
                                ${job.status === 'running' && job.progress > 0 ? 
                                  `<div><strong>Progress:</strong> ${job.progress.toFixed(1)}%</div>` : 
                                  ''}
                                <div><strong>Duration:</strong> ${duration}</div>
                                <div><strong>Started:</strong> ${new Date(job.startTime).toLocaleString()}</div>
                                ${job.stats.filesProcessed ? `<div><strong>Files:</strong> ${job.stats.filesProcessed}${job.stats.filesTotal ? `/${job.stats.filesTotal}` : ''} processed, ${job.stats.chunksIndexed} chunks</div>` : ''}
                                ${job.error ? `<div style="color: #e74c3c;"><strong>Error:</strong> ${job.error}</div>` : ''}
                            </div>
                            ${progressBar}
                        </div>
                    `;
                }).join('');
                
            } catch (error) {
                log(`‚ùå Error loading jobs: ${error.message}`);
            }
        }

        // Modal management
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                if (event.target == modal) {
                    modal.style.display = 'none';
                }
            });
        }

        // Real-time log streaming (auto-connects)
        let logStream = null;
        let logStreamActive = false;
        const statusEl = document.getElementById('log-status');

        function updateLogStatus(message, color = '#666') {
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.style.color = color;
            }
        }

        function startLogStream() {
            if (logStream) {
                logStream.close();
            }
            
            logStream = new EventSource('/api/logs/stream');
            logStreamActive = true;
            updateLogStatus('Connecting...', '#f39c12');
            
            logStream.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.type === 'connected') {
                        updateLogStatus('üî¥ Live streaming server.log', '#27ae60');
                    } else if (data.type === 'historical') {
                        // Show historical logs in a muted style
                        log(data.message);
                    } else if (data.type === 'live') {
                        // Show live logs normally
                        log(data.message);
                        // Ensure status shows normal streaming after clearing
                        if (statusEl && statusEl.textContent.includes('cleared')) {
                            updateLogStatus('üî¥ Live streaming server.log', '#27ae60');
                        }
                    } else if (data.type === 'cleared') {
                        // Handle log clearing notification
                        log(data.message);
                        updateLogStatus('üî¥ Live streaming (logs cleared)', '#f39c12');
                        // Status will return to normal with next live log
                    } else if (data.type === 'file_missing') {
                        // Handle missing log file
                        log(data.message);
                        updateLogStatus('‚ö†Ô∏è Waiting for log file...', '#e74c3c');
                    }
                } catch (error) {
                    console.error('Error parsing log stream data:', error);
                }
            };

            logStream.onerror = function(event) {
                updateLogStatus('‚ùå Connection error - reconnecting...', '#e74c3c');
                logStreamActive = false;
                
                // Auto-reconnect after 3 seconds
                setTimeout(() => {
                    if (!logStreamActive) {
                        startLogStream();
                    }
                }, 3000);
            };

            logStream.onopen = function(event) {
                updateLogStatus('üì° Connected to log stream', '#3498db');
            };
        }
        // Load projects and jobs on page load
        window.addEventListener('load', () => {
            loadProjects();
            loadJobs();
            
            // Auto-start log streaming
            startLogStream();
            
            // Auto-refresh jobs every 10 seconds
            setInterval(loadJobs, 10000);
        });
        
        // Add some initial logs (will be replaced by server stream)
        log('Vector MCP Index Manager initialized');
        log('Connecting to server log stream...');
    </script>
</body>
</html>